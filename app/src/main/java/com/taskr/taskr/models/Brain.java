package com.taskr.taskr.models;

/**
 * Created by Kenan Millet on 11/27/2016.
 */

import java.text.DateFormat;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.Collections;
import java.util.Comparator;
import java.util.Date;
import java.util.List;

public class Brain {
    public Brain(final float des, final float imp, final float dur, final float urg) {
        this.desWeight = des;
        this.impWeight = imp;
        this.durWeight = dur;
        this.urgWeight = urg;
    }

    public Schedule autoSchedule(Date begin, Date end, ArrayList<Task> tasks) {
        return autoSchedule(begin, end, tasks, 1.0f);
    }
    public Schedule autoSchedule(Date begin, Date end, ArrayList<Task> tasks, float timeInterval) {
        final Schedule schedule = new Schedule("Taskr Auto-Generated Schedule", begin, end);

        ArrayList<Task> splits = splitTasks(tasks, timeInterval);

        for (Task t : splits)
        {
            t.setPriority(getPriority(splits.indexOf(t), splits));
            schedule.addTask(t);
        }

        //now that all tasks have been split up and/or added to the schedule,
        //sort schedule task list by priority
        Collections.sort(schedule.getTasks(), new Comparator<Task>() {
            @Override
            public int compare(Task o1, Task o2) {
                return (int)(o1.getPriority() - o2.getPriority());
            }
        });

        //fill the schedule by setting the start/end dates of the tasks
        for (Task t : schedule.getTasks()) {
            if(t.getManual()) continue;
            for (Date d = new Date(begin.getTime()), e = addToDate(d, Calendar.MINUTE, (int) (timeInterval * 60)); e.before(end); d = addToDate(d, Calendar.MINUTE, (int) (timeInterval * 60)), e = addToDate(e, Calendar.MINUTE, (int) (timeInterval * 60))) {
                if (schedule.isTimeSlotAvailable(d, e)) {
                    t.setStartDate(d);
                    t.setEndDate(e);
                    break;
                }
            }
        }

        DateFormat boundformat = new SimpleDateFormat("[dd/MM/yyyy]");
        DateFormat timestamp = new SimpleDateFormat("[dd/MM/yyyy hh:mm:ss a].");

        schedule.setNotes("Taskr thinks this schedule is optimal for your work habits. Schedule from " + boundformat.format(begin) + " to " + boundformat.format(end) + " automatically generated by Taskr on " + timestamp.format(new Date()));
        return schedule;
    }

    public float getPriority(int index, ArrayList<Task> tasks) {
        return getPriority(index, tasks, 0.0f, new Date());
    }
    public float getPriority(int index, ArrayList<Task> tasks, float offset, Date refTime) {
        Task t = tasks.get(index);
        if (t.getManual()) return 2.0f;

        final float des = t.getDesirability();
        final float imp = t.getImportance();
        final double time = urgWeight * getTimeAvailability(index, tasks, offset, refTime);
        final double c = 1.0 - (t.getCompletion() + offset);
        final double x = ((time > 0) ? (durWeight * timeNeeded(t, offset)) / time : 1.0f);
        final double p0 = des * desWeight * c / 100.0;
        final double p1 = 1.0 - Math.pow(1.0 - (des * c / 10.0), desWeight);
        final double p2 = 1.0 - Math.pow(1.0 - (imp * c / 10.0), impWeight);
        final double p3 = 1.0;

        return (float) ((x < 1.0) ? ((Math.pow(1.0 - x, 3.0) * p0) + (Math.pow(1.0 - x, 2.0) * x * 3.0 * p1) + ((1.0 - x) * Math.pow(x, 2.0) * 3.0 * p2) + (Math.pow(x, 3.0) * p3)) : 1.0);
    }

    public int getNumParts(Task t, float timeInterval) {
        return (int) (timeNeeded(t) / timeInterval) + ((timeNeeded(t) % timeInterval == 0.0f) ? 0 : 1);
    }

    public float getDuration(Task t, float timeInterval, int n) {
        return ((timeNeeded(t) - ((float) n) * timeInterval < 0.0f) ? timeNeeded(t) : timeInterval);
    }

    private float desWeight;
    private float impWeight;
    private float durWeight;
    private float urgWeight;

    float timeRemaining(Task t) {
        return timeRemaining(t, new Date());
    }

    private float timeRemaining(Task t, Date refTime) {
        return (float) (((double) (t.getUrgency().getTime() - refTime.getTime())) / (60.0 * 60.0 * 1000.0));
    }

    float timeNeeded(Task t) {
        return timeNeeded(t, 0.0f);
    }

    private float timeNeeded(Task t, float offset) {
        return (1.0f - (t.getCompletion() + offset)) * t.getDuration();
    }

    private float getTimeAvailability(int index, ArrayList<Task> tasks) {
        return getTimeAvailability(index, tasks, 0.0f, new Date());
    }

    private float getTimeAvailability(int index, ArrayList<Task> tasks, float offset, Date refTime) {
        float totalOccupancy = 0.0f;
        ArrayList<Task> tasklist = new ArrayList(tasks);
        Collections.sort(tasklist, new Comparator<Task>() {
            @Override
            public int compare(Task o1, Task o2) {
                return o1.getUrgency().compareTo(o2.getUrgency());
            }
        });
        List<Task> tlist = tasklist.subList(0, index);
        for (Task t : tasklist) {
            totalOccupancy += timeNeeded(t, offset);
        }

        return timeRemaining(tasks.get(index), refTime) - totalOccupancy;
    }

    Date addToDate(Date d, int field, int amount) {
        Calendar cal = Calendar.getInstance();
        cal.setTime(d);
        cal.add(field, amount);
        return cal.getTime();
    }

    public ArrayList<Task> splitTasks(ArrayList<Task> tasks, float timeInterval) {
        ArrayList<Task> schedule = new ArrayList<>();
        Collections.sort(tasks, new Comparator<Task>() {
            @Override
            public int compare(Task o1, Task o2) {
                return (o1.getManual() ? -1 : 1);
            }
        });
        for(Task t : tasks) //split up auto tasks into pieces no greater than timeInterval and add to schedule
        {
            if(t.getManual()) schedule.add(t);
            else
            {
                int nparts = (int) (timeNeeded(t) / timeInterval) + ((timeNeeded(t) % timeInterval == 0.0f) ? 0 : 1);
                float comp = t.getCompletion(); //store original completion since we will be modifying it
                for (int n = 1; n <= nparts; ++n) {
                    //calculate how long the task interval will be in the range (0-timeInterval]
                    float time = ((timeNeeded(t) - timeInterval < 0.0f) ? timeNeeded(t) : timeInterval);
                    //add the split up task interval to the schedule task list
                    Task task = new Task(t);
                    task.setName(t.getName() + String.format(" (%1$d of %2$d)", n, nparts));
                    task.setDuration(time);
                    task.setStartDate(new Date(0L));
                    task.setEndDate(new Date(0L));
                    schedule.add(task);
                    t.setCompletion(t.getCompletion() + (time / t.getDuration())); //add to completion the % we accomplished with this time interval
                }
                t.setCompletion(comp);
            }
        }
        return schedule;
    }
}
